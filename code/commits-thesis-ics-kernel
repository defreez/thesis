commit 5920119e16641ca3c0abfed4ec7e16324c7c4c79
Author: Daniel DeFreez <daniel@defreez.com>
Date:   Tue Feb 14 21:53:44 2012 -0800

    Added the ability to clear/add keys through misdev
    
    The master key (derived from pass) can be cleared or added.
    The user keyring is *not* touched. The key must also be removed from the keyring to prevent decryption.
    Adding a key also assumes the key has been added to the appropriate keyring.
    Boundary keys can be removed, but not added.

diff --git a/fs/ecryptfs/ecryptfs_kernel.h b/fs/ecryptfs/ecryptfs_kernel.h
index 391c7ef..fe2d2ae 100644
--- a/fs/ecryptfs/ecryptfs_kernel.h
+++ b/fs/ecryptfs/ecryptfs_kernel.h
@@ -441,6 +441,7 @@ struct ecryptfs_msg_ctx {
 #define ECRYPTFS_MSG_RESPONSE 103
 #define ECRYPTFS_MSG_CLEARMASTER 104
 #define ECRYPTFS_MSG_CLEARBOUNDARY 105
+#define ECRYPTFS_MSG_REGMASTER 106
 
 	u8 type;
 	u32 index;
@@ -786,6 +787,9 @@ void ecryptfs_generate_boundary_key(struct ecryptfs_crypt_stat *crypt_stat,
 				    struct ecryptfs_auth_tok *auth_tok,
 				    struct ecryptfs_boundary_key **boundary_key);
 				   
-int ecryptfs_clear_master(void);
-int ecryptfs_clear_boundary(uid_t uid);
+int ecryptfs_path_to_crypt_stat(char *path, struct ecryptfs_mount_crypt_stat **mount_crypt_stat);
+void ecryptfs_clear_master(struct ecryptfs_mount_crypt_stat *mount_crypt_stat);
+int ecryptfs_reg_master(struct ecryptfs_mount_crypt_stat *mount_crypt_stat, char *sig);
+int ecryptfs_clear_boundary(struct ecryptfs_mount_crypt_stat *mount_crypt_stat, uid_t uid);
+int ecryptfs_init_global_auth_toks(struct ecryptfs_mount_crypt_stat *mount_crypt_stat);
 #endif /* #ifndef ECRYPTFS_KERNEL_H */
diff --git a/fs/ecryptfs/file.c b/fs/ecryptfs/file.c
index 1745359..356e227 100644
--- a/fs/ecryptfs/file.c
+++ b/fs/ecryptfs/file.c
@@ -264,6 +264,11 @@ static int ecryptfs_flush(struct file *file, fl_owner_t td)
 
 static int ecryptfs_release(struct inode *inode, struct file *file)
 {
+	struct ecryptfs_crypt_stat *crypt_stat = NULL;
+
+	crypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;
+	memset(crypt_stat->key, 0, ECRYPTFS_MAX_KEY_BYTES);
+	crypt_stat->flags &= ~ECRYPTFS_KEY_VALID;
 	ecryptfs_put_lower_file(inode);
 	kmem_cache_free(ecryptfs_file_info_cache,
 			ecryptfs_file_to_private(file));
diff --git a/fs/ecryptfs/keystore.c b/fs/ecryptfs/keystore.c
index 48cd486..c1b1b9a 100644
--- a/fs/ecryptfs/keystore.c
+++ b/fs/ecryptfs/keystore.c
@@ -1679,10 +1679,9 @@ out:
  */
 static int
 decrypt_passphrase_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,
-					 struct ecryptfs_crypt_stat *crypt_stat)
+					 struct ecryptfs_crypt_stat *crypt_stat,
+					 struct ecryptfs_boundary_key *boundary_key)
 {
-	struct ecryptfs_boundary_key *boundary_key;
-	u8 decryption_key[16];
 	struct scatterlist dst_sg[2];
 	struct scatterlist src_sg[2];
 	struct mutex *tfm_mutex;
@@ -1695,15 +1694,12 @@ decrypt_passphrase_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,
 	if (!ecryptfs_find_boundary_key(crypt_stat->mount_crypt_stat, 
 				   crypt_stat->boundary_uid, &boundary_key)) 
 	{
-		ecryptfs_generate_boundary_key(crypt_stat,
-					       auth_tok, &boundary_key);
 	}
-	memcpy(decryption_key, boundary_key->key, crypt_stat->key_size);
 
 	if (unlikely(ecryptfs_verbosity > 0)) {
 		ecryptfs_printk(
 			KERN_DEBUG, "Session key encryption key:\n")
-		ecryptfs_dump_hex(decryption_key, crypt_stat->key_size);
+		ecryptfs_dump_hex(boundary_key->key, crypt_stat->key_size);
 	}
 	rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,
 							crypt_stat->cipher);
@@ -1737,7 +1733,7 @@ decrypt_passphrase_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,
 	}
 	mutex_lock(tfm_mutex);
 	rc = crypto_blkcipher_setkey(
-		desc.tfm, decryption_key,
+		desc.tfm, boundary_key->key,
 		crypt_stat->key_size);
 	if (unlikely(rc < 0)) {
 		mutex_unlock(tfm_mutex);
@@ -1789,6 +1785,7 @@ int ecryptfs_parse_packet_set(struct ecryptfs_crypt_stat *crypt_stat,
 	struct list_head auth_tok_list;
 	struct ecryptfs_auth_tok *matching_auth_tok;
 	struct ecryptfs_auth_tok *candidate_auth_tok;
+	struct ecryptfs_boundary_key *boundary_key = NULL;
 	char *candidate_auth_tok_sig;
 	size_t packet_size;
 	struct ecryptfs_auth_tok *new_auth_tok;
@@ -1892,6 +1889,9 @@ int ecryptfs_parse_packet_set(struct ecryptfs_crypt_stat *crypt_stat,
 	 * the metadata. There may be several potential matches, but
 	 * just one will be sufficient to decrypt to get the FEK. */
 find_next_matching_auth_tok:
+	// Look for a boundary key we can use in lieu of global
+	ecryptfs_find_boundary_key(crypt_stat->mount_crypt_stat,
+	    crypt_stat->boundary_uid, &boundary_key); 
 	found_auth_tok = 0;
 	list_for_each_entry(auth_tok_list_item, &auth_tok_list, list) {
 		candidate_auth_tok = &auth_tok_list_item->auth_tok;
@@ -1916,6 +1916,9 @@ find_next_matching_auth_tok:
 		if (!rc) {
 			found_auth_tok = 1;
 			goto found_matching_auth_tok;
+		} else if (boundary_key) {
+			// We check here to ensure that we have a candidate
+			goto found_matching_auth_tok;
 		}
 	}
 	if (!found_auth_tok) {
@@ -1934,15 +1937,17 @@ found_matching_auth_tok:
 		rc = decrypt_pki_encrypted_session_key(candidate_auth_tok,
 						       crypt_stat);
 	} else if (candidate_auth_tok->token_type == ECRYPTFS_PASSWORD) {
-	// If Boundary mode, we should lookup by uid and copy that private key
-	// If uid lookup fails, then derive
-		memcpy(&(candidate_auth_tok->token.password),
-		       &(matching_auth_tok->token.password),
-		       sizeof(struct ecryptfs_password));
-		up_write(&(auth_tok_key->sem));
-		key_put(auth_tok_key);
+		if (!boundary_key) {
+			ecryptfs_generate_boundary_key(crypt_stat,
+						       matching_auth_tok,
+						       &boundary_key);
+		}
+		if (found_auth_tok) {
+			up_write(&(auth_tok_key->sem));
+			key_put(auth_tok_key);
+		}
 		rc = decrypt_passphrase_encrypted_session_key(
-			candidate_auth_tok, crypt_stat);
+			candidate_auth_tok, crypt_stat, boundary_key);
 	} else {
 		up_write(&(auth_tok_key->sem));
 		key_put(auth_tok_key);
@@ -2565,13 +2570,79 @@ out:
 	return rc;
 }
 
-int ecryptfs_clear_master()
+
+void ecryptfs_clear_master(struct ecryptfs_mount_crypt_stat *mount_crypt_stat) 
 {
-	printk(KERN_DEBUG "Request received to clear master key");
-	return 0;
+	struct list_head *global_auth_tok_list;
+	struct ecryptfs_global_auth_tok *walker;
+	struct ecryptfs_global_auth_tok *walker_tmp;
+
+	global_auth_tok_list = &mount_crypt_stat->global_auth_tok_list;
+	mutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);
+	list_for_each_entry_safe(walker, walker_tmp, global_auth_tok_list,
+				 mount_crypt_stat_list) {
+		list_del(&walker->mount_crypt_stat_list);
+		memset(walker, 0, sizeof(walker));
+		kmem_cache_free(ecryptfs_global_auth_tok_cache,
+				walker);
+	}
+	mutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);
 }
 
-int ecryptfs_clear_boundary(uid_t uid) {
-	printk(KERN_DEBUG "Request received to clear boundary for uid [%d]", uid);
-	return 0;
+int ecryptfs_reg_master(struct ecryptfs_mount_crypt_stat *mount_crypt_stat,
+			char *sig)
+{
+	struct ecryptfs_global_auth_tok *walker;
+	struct list_head *global_auth_tok_list;
+	int rc = 0;
+
+	global_auth_tok_list = &mount_crypt_stat->global_auth_tok_list;
+	mutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);
+	list_for_each_entry(walker, global_auth_tok_list,
+			    mount_crypt_stat_list) {
+		if (!memcmp(walker->sig, sig, ECRYPTFS_SIG_SIZE_HEX)) {
+			mutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);
+			ecryptfs_printk(KERN_INFO, "Ignoring attempt to add existing"
+				" signature");
+			return -1;
+		}
+
+	}
+	mutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);
+	rc = ecryptfs_add_global_auth_tok(mount_crypt_stat, sig, 0);
+	if (rc) {
+		ecryptfs_printk(KERN_WARNING, "Failed to add token to list");
+	}
+	rc = ecryptfs_init_global_auth_toks(mount_crypt_stat);
+	if (rc) {
+		printk(KERN_WARNING "One or more global auth toks could not "
+		       "properly register; rc = [%d]\n", rc);
+		// The key was not in keyring, so back out
+		ecryptfs_clear_master(mount_crypt_stat);
+	}
+
+	return rc;
+}
+
+int ecryptfs_clear_boundary(struct ecryptfs_mount_crypt_stat *mount_crypt_stat,
+			    uid_t uid) 
+{
+	struct ecryptfs_boundary_key *walker = NULL;
+	struct ecryptfs_boundary_key *walker_tmp = NULL;
+	int rc = 0;
+
+	list_for_each_entry_safe(walker, walker_tmp,
+				 &mount_crypt_stat->boundary_key_list, 
+				 mount_crypt_stat_list) {
+		if (walker->uid == uid) {
+			list_del(&walker->mount_crypt_stat_list);
+			memset(walker, 0, sizeof(walker));
+			goto out;
+		}
+	}
+	rc = -1;
+	ecryptfs_printk(KERN_WARNING, "Request to remove non-existant boundary"
+				   "key - ignoring.");
+out:
+	return rc;
 }
diff --git a/fs/ecryptfs/main.c b/fs/ecryptfs/main.c
index a74c270..28c8737 100644
--- a/fs/ecryptfs/main.c
+++ b/fs/ecryptfs/main.c
@@ -196,7 +196,7 @@ static const match_table_t tokens = {
 	{ecryptfs_opt_err, NULL}
 };
 
-static int ecryptfs_init_global_auth_toks(
+int ecryptfs_init_global_auth_toks(
 	struct ecryptfs_mount_crypt_stat *mount_crypt_stat)
 {
 	struct ecryptfs_global_auth_tok *global_auth_tok;
@@ -584,6 +584,32 @@ out:
 	return ERR_PTR(rc);
 }
 
+int ecryptfs_path_to_crypt_stat(char *name, 
+	struct ecryptfs_mount_crypt_stat **mount_crypt_stat) 
+{
+	struct path path;
+	int rc;
+
+	rc = kern_path(name, LOOKUP_DIRECTORY, &path);
+	if (rc) {
+		ecryptfs_printk(KERN_WARNING, "kern_path() failed\n");
+		goto out;
+	} 
+	if (path.dentry->d_sb->s_type != &ecryptfs_fs_type) {
+	ecryptfs_printk(KERN_WARNING, "Attempted to get crypt_stat for "
+		"non-eCryptfs mount\n");
+		rc = -1;
+		goto out_free;
+	}
+
+	*mount_crypt_stat = &ecryptfs_superblock_to_private(
+			path.dentry->d_sb)->mount_crypt_stat;
+out_free:
+	path_put(&path);
+out:
+	return rc;
+}
+
 /**
  * ecryptfs_kill_block_super
  * @sb: The ecryptfs super block
diff --git a/fs/ecryptfs/miscdev.c b/fs/ecryptfs/miscdev.c
index b74cf24..3a744d6 100644
--- a/fs/ecryptfs/miscdev.c
+++ b/fs/ecryptfs/miscdev.c
@@ -409,6 +409,9 @@ ecryptfs_miscdev_write(struct file *file, const char __user *buf,
 	ssize_t sz = 0;
 	char *data;
 	uid_t euid = current_euid();
+	struct ecryptfs_mount_crypt_stat *mount_crypt_stat = NULL;
+	char *key_sig;
+	uid_t boundary_uid;
 	int rc;
 
 	if (count == 0)
@@ -461,25 +464,91 @@ ecryptfs_miscdev_write(struct file *file, const char __user *buf,
 			       __func__, rc);
 		break;
 	case ECRYPTFS_MSG_CLEARMASTER:
-		rc = ecryptfs_clear_master();
-		if (rc)
-			printk(KERN_WARNING "%s: Failed to clear master key! rc = [%d]",
-				__func__, rc);
-		break;
-	case ECRYPTFS_MSG_CLEARBOUNDARY:
-		if (count != (1 + 4 + 1 + sizeof(uid_t) + sizeof(struct ecryptfs_message))) {
-			printk(KERN_WARNING "%s: CLEARBOUNDARY message size size must be "
+		/* CLEARMASTER MSG FORMAT 
+		 * N bytes: path to mount point 
+		 */
+		if (count < (1 + 4 + 1 + sizeof(struct ecryptfs_message))) {
+			printk(KERN_WARNING "%s: CLEARMASTER must be >t"
 			       "[%zd], but amount of data written is "
 			       "[%zd]. Discarding response packet.\n",
 			       __func__,
-			       (1 + 4 + 1 + sizeof(uid_t) + sizeof(struct ecryptfs_message)),
+			       (1 + 4 + 1 + sizeof(struct ecryptfs_message)),
 			       count);
 			goto out_free;
 		}
-		rc = ecryptfs_clear_boundary(*((uid_t*) &data[1 + 4 + 1 + sizeof(struct ecryptfs_message)]));
-		if (rc)
-			printk(KERN_WARNING "%s: Failed to clear boundary key! rc = [%d]",
-				__func__, rc);
+		i += 1 + 4 + sizeof(struct ecryptfs_message);
+
+		rc = ecryptfs_path_to_crypt_stat((char *) &data[i],
+						 &mount_crypt_stat); if (rc) {
+			printk(KERN_WARNING "CLEARMASTER on unmounted Volume");
+			break;
+		}
+		// Pass message contents and size to ecryptfs_clear_master
+		// Message should be the path to mount point for path_lookup
+		ecryptfs_clear_master(mount_crypt_stat);
+		break;
+	case ECRYPTFS_MSG_REGMASTER:
+		/* REGMASTER MSG FORMAT
+		 * ECRYPTFS_SIG_SIZE_HEX bytes: sig of key in keyring
+		 * N bytes: path to mount point
+		 */
+		if (count < (1 + 4 + 1 + ECRYPTFS_SIG_SIZE_HEX + 1 + 1 +
+					sizeof(struct ecryptfs_message))) { 
+			printk(KERN_WARNING "%s: REGMASTER must be >"
+			       "[%zd], but amount of data written is "
+			       "[%zd]. Discarding response packet.\n",
+			       __func__,
+			       (1 + 4 + 1 + ECRYPTFS_SIG_SIZE_HEX + 1  + 1 +
+			       	sizeof(struct ecryptfs_message)), count);
+			goto out_free;
+		}
+		i += 1 + 4 + sizeof(struct ecryptfs_message);
+
+		key_sig = kmalloc(ECRYPTFS_SIG_SIZE_HEX + 1, GFP_KERNEL);
+		rc = strlcpy(key_sig, &data[i], ECRYPTFS_SIG_SIZE_HEX + 1);
+		if (rc != ECRYPTFS_SIG_SIZE_HEX) {
+			printk(KERN_WARNING "REGMASTER: Bad signature size");
+			goto regmaster_free;
+		}
+		i += ECRYPTFS_SIG_SIZE_HEX + 1;
+		rc = ecryptfs_path_to_crypt_stat((char *) &data[i],
+						 &mount_crypt_stat); 
+		if (rc) {
+			printk(KERN_WARNING "REGMASTER: Unmounted Volume");
+			goto regmaster_free;
+		}
+		rc = ecryptfs_reg_master(mount_crypt_stat, key_sig);
+		if (rc) {
+			printk(KERN_ERR "REGMASTER: Failed to add"
+					"global_auth_tok"); 
+			goto regmaster_free;
+		}
+regmaster_free:
+		kfree(key_sig);
+		break;
+	case ECRYPTFS_MSG_CLEARBOUNDARY:
+		/* CLEARBOUNDARY MSG FORMAT
+		 * uid_t: uid of boundary to clear
+		 * N bytes: path to mount point
+		 */
+		if (count < (1 + 4 + 1 + sizeof(uid_t) + 1 + 
+					 sizeof(struct ecryptfs_message))) {
+			printk(KERN_WARNING "%s: CLEARBOUNDARY must be >"
+			       "[%zd]; received [%zd] - discarding.\n",
+			       __func__, (1 + 4 + 1 + sizeof(uid_t) + 1 + 
+			       sizeof(struct ecryptfs_message)), count);
+			goto out_free;
+		}
+		i += 1 + 4 + sizeof(struct ecryptfs_message);
+		memcpy(&boundary_uid, &data[i], sizeof(uid_t));
+		i += sizeof(uid_t);
+		rc = ecryptfs_path_to_crypt_stat((char *) &data[i],
+						 &mount_crypt_stat); 
+		if (rc) {
+			printk(KERN_WARNING "CLEARBOUNDARY: Unmounted Volume");
+			break;
+		}
+		ecryptfs_clear_boundary(mount_crypt_stat, boundary_uid);
 		break;
 	case ECRYPTFS_MSG_HELO:
 	case ECRYPTFS_MSG_QUIT:

commit 30ae855f1e9dac43e4c35b252387b4dda1cdcead
Author: Daniel DeFreez <daniel@defreez.com>
Date:   Tue Feb 14 11:50:20 2012 -0800

    modified messages for clearing keys: one msg per boundary

diff --git a/fs/ecryptfs/ecryptfs_kernel.h b/fs/ecryptfs/ecryptfs_kernel.h
index 59c24c2..391c7ef 100644
--- a/fs/ecryptfs/ecryptfs_kernel.h
+++ b/fs/ecryptfs/ecryptfs_kernel.h
@@ -439,8 +439,9 @@ struct ecryptfs_msg_ctx {
 #define ECRYPTFS_MSG_QUIT 101
 #define ECRYPTFS_MSG_REQUEST 102
 #define ECRYPTFS_MSG_RESPONSE 103
-#define ECRYPTFS_MSG_CLEARMASTER_BLACK 104
-#define ECRYPTFS_MSG_CLEARMASTER_WHITE 105
+#define ECRYPTFS_MSG_CLEARMASTER 104
+#define ECRYPTFS_MSG_CLEARBOUNDARY 105
+
 	u8 type;
 	u32 index;
 	/* Counter converts to a sequence number. Each message sent
@@ -785,4 +786,6 @@ void ecryptfs_generate_boundary_key(struct ecryptfs_crypt_stat *crypt_stat,
 				    struct ecryptfs_auth_tok *auth_tok,
 				    struct ecryptfs_boundary_key **boundary_key);
 				   
+int ecryptfs_clear_master(void);
+int ecryptfs_clear_boundary(uid_t uid);
 #endif /* #ifndef ECRYPTFS_KERNEL_H */
diff --git a/fs/ecryptfs/keystore.c b/fs/ecryptfs/keystore.c
index f19b881..48cd486 100644
--- a/fs/ecryptfs/keystore.c
+++ b/fs/ecryptfs/keystore.c
@@ -2565,3 +2565,13 @@ out:
 	return rc;
 }
 
+int ecryptfs_clear_master()
+{
+	printk(KERN_DEBUG "Request received to clear master key");
+	return 0;
+}
+
+int ecryptfs_clear_boundary(uid_t uid) {
+	printk(KERN_DEBUG "Request received to clear boundary for uid [%d]", uid);
+	return 0;
+}
diff --git a/fs/ecryptfs/miscdev.c b/fs/ecryptfs/miscdev.c
index a50b39e..b74cf24 100644
--- a/fs/ecryptfs/miscdev.c
+++ b/fs/ecryptfs/miscdev.c
@@ -460,8 +460,26 @@ ecryptfs_miscdev_write(struct file *file, const char __user *buf,
 			       "response to requesting operation; rc = [%d]\n",
 			       __func__, rc);
 		break;
-	case ECRYPTFS_MSG_CLEARMASTER_BLACK:
-		printk(KERN_DEBUG "Clear the master key with blacklist");
+	case ECRYPTFS_MSG_CLEARMASTER:
+		rc = ecryptfs_clear_master();
+		if (rc)
+			printk(KERN_WARNING "%s: Failed to clear master key! rc = [%d]",
+				__func__, rc);
+		break;
+	case ECRYPTFS_MSG_CLEARBOUNDARY:
+		if (count != (1 + 4 + 1 + sizeof(uid_t) + sizeof(struct ecryptfs_message))) {
+			printk(KERN_WARNING "%s: CLEARBOUNDARY message size size must be "
+			       "[%zd], but amount of data written is "
+			       "[%zd]. Discarding response packet.\n",
+			       __func__,
+			       (1 + 4 + 1 + sizeof(uid_t) + sizeof(struct ecryptfs_message)),
+			       count);
+			goto out_free;
+		}
+		rc = ecryptfs_clear_boundary(*((uid_t*) &data[1 + 4 + 1 + sizeof(struct ecryptfs_message)]));
+		if (rc)
+			printk(KERN_WARNING "%s: Failed to clear boundary key! rc = [%d]",
+				__func__, rc);
 		break;
 	case ECRYPTFS_MSG_HELO:
 	case ECRYPTFS_MSG_QUIT:

commit c7f6a6707c659798ea29c6e9c0d6f72e5267cd59
Author: Daniel DeFreez <daniel@defreez.com>
Date:   Mon Feb 13 22:39:36 2012 -0800

    support extra messages for wiping keys

diff --git a/fs/ecryptfs/ecryptfs_kernel.h b/fs/ecryptfs/ecryptfs_kernel.h
index 82aee2a..59c24c2 100644
--- a/fs/ecryptfs/ecryptfs_kernel.h
+++ b/fs/ecryptfs/ecryptfs_kernel.h
@@ -439,6 +439,8 @@ struct ecryptfs_msg_ctx {
 #define ECRYPTFS_MSG_QUIT 101
 #define ECRYPTFS_MSG_REQUEST 102
 #define ECRYPTFS_MSG_RESPONSE 103
+#define ECRYPTFS_MSG_CLEARMASTER_BLACK 104
+#define ECRYPTFS_MSG_CLEARMASTER_WHITE 105
 	u8 type;
 	u32 index;
 	/* Counter converts to a sequence number. Each message sent
diff --git a/fs/ecryptfs/miscdev.c b/fs/ecryptfs/miscdev.c
index 940a82e..a50b39e 100644
--- a/fs/ecryptfs/miscdev.c
+++ b/fs/ecryptfs/miscdev.c
@@ -460,6 +460,9 @@ ecryptfs_miscdev_write(struct file *file, const char __user *buf,
 			       "response to requesting operation; rc = [%d]\n",
 			       __func__, rc);
 		break;
+	case ECRYPTFS_MSG_CLEARMASTER_BLACK:
+		printk(KERN_DEBUG "Clear the master key with blacklist");
+		break;
 	case ECRYPTFS_MSG_HELO:
 	case ECRYPTFS_MSG_QUIT:
 		break;

commit cc537ee774032845bc7999ebc98cf444e60fbcd5
Author: Daniel DeFreez <defreezda@sou.edu>
Date:   Sat Jan 14 12:31:20 2012 -0800

    Implement boundary keys.
    
    Each file receives a separate key based on owner UID.

diff --git a/fs/ecryptfs/crypto.c b/fs/ecryptfs/crypto.c
index 81bff8a..062b546 100644
--- a/fs/ecryptfs/crypto.c
+++ b/fs/ecryptfs/crypto.c
@@ -200,6 +200,7 @@ int ecryptfs_derive_iv(char *iv, struct ecryptfs_crypt_stat *crypt_stat,
 	}
 	rc = ecryptfs_calculate_md5(dst, crypt_stat, src,
 				    (crypt_stat->iv_bytes + 16));
+
 	if (rc) {
 		ecryptfs_printk(KERN_WARNING, "Error attempting to compute "
 				"MD5 while generating IV for a page\n");
@@ -837,6 +838,45 @@ out:
 	return rc;
 }
 
+// should be int, returning true false based upon key status of master
+void ecryptfs_generate_boundary_key(struct ecryptfs_crypt_stat *crypt_stat,
+				    struct ecryptfs_auth_tok *auth_tok,
+				    struct ecryptfs_boundary_key **boundary_key)
+{
+	char *tmp;
+	int master_sz;
+	struct ecryptfs_boundary_key *new_key = NULL; 
+	struct ecryptfs_mount_crypt_stat *mount_crypt_stat =
+		crypt_stat->mount_crypt_stat;
+
+
+	if (ecryptfs_find_boundary_key(mount_crypt_stat, 
+				       crypt_stat->boundary_uid, boundary_key)) 
+		goto out;	
+
+	new_key = kmalloc(sizeof(struct ecryptfs_boundary_key), GFP_KERNEL);
+
+	master_sz = auth_tok->token.password.session_key_encryption_key_bytes;
+	tmp = kmalloc(sizeof(uid_t) + master_sz, GFP_KERNEL);
+
+	memcpy(tmp, auth_tok->token.password.session_key_encryption_key, master_sz);
+	memcpy(tmp + master_sz, &crypt_stat->boundary_uid, sizeof(uid_t));
+
+	ecryptfs_calculate_md5(new_key->key, crypt_stat, tmp, 
+				master_sz + sizeof(uid_t));
+	new_key->uid = crypt_stat->boundary_uid;
+
+	list_add(&new_key->mount_crypt_stat_list, 
+		 &mount_crypt_stat->boundary_key_list);
+	*boundary_key = new_key;
+
+	if (unlikely(ecryptfs_verbosity > 0)) {
+		ecryptfs_printk(KERN_DEBUG, "Generated boundary key");
+	}
+out:
+	return;
+}
+
 static void ecryptfs_generate_new_key(struct ecryptfs_crypt_stat *crypt_stat)
 {
 	get_random_bytes(crypt_stat->key, crypt_stat->key_size);
@@ -979,6 +1019,9 @@ int ecryptfs_new_file_context(struct dentry *ecryptfs_dentry)
 		ecryptfs_printk(KERN_ERR, "Error initializing cryptographic "
 				"context for cipher [%s]: rc = [%d]\n",
 				crypt_stat->cipher, rc);
+
+	// Set boundary id for FEKEK generation
+	crypt_stat->boundary_uid = ecryptfs_dentry->d_inode->i_uid;
 out:
 	return rc;
 }
diff --git a/fs/ecryptfs/ecryptfs_kernel.h b/fs/ecryptfs/ecryptfs_kernel.h
index 43c7c43..82aee2a 100644
--- a/fs/ecryptfs/ecryptfs_kernel.h
+++ b/fs/ecryptfs/ecryptfs_kernel.h
@@ -85,6 +85,7 @@
 #define ECRYPTFS_DEFAULT_NUM_USERS 4
 #define ECRYPTFS_MAX_NUM_USERS 32768
 #define ECRYPTFS_XATTR_NAME "user.ecryptfs"
+#define BOUNDARY_MODE 1
 
 #define RFC2440_CIPHER_DES3_EDE 0x02
 #define RFC2440_CIPHER_CAST_5 0x03
@@ -287,6 +288,7 @@ struct ecryptfs_crypt_stat {
 	unsigned char cipher[ECRYPTFS_MAX_CIPHER_NAME_SIZE];
 	unsigned char key[ECRYPTFS_MAX_KEY_BYTES];
 	unsigned char root_iv[ECRYPTFS_MAX_IV_BYTES];
+	uid_t boundary_uid;
 	struct list_head keysig_list;
 	struct mutex keysig_list_mutex;
 	struct mutex cs_tfm_mutex;
@@ -339,6 +341,12 @@ struct ecryptfs_global_auth_tok {
 	unsigned char sig[ECRYPTFS_SIG_SIZE_HEX + 1];
 };
 
+struct ecryptfs_boundary_key {
+	struct list_head mount_crypt_stat_list;
+	char key[16];
+	uid_t uid;
+};
+
 /**
  * ecryptfs_key_tfm - Persistent key tfm
  * @key_tfm: crypto API handle to the key
@@ -382,6 +390,7 @@ struct ecryptfs_mount_crypt_stat {
 	u32 flags;
 	struct list_head global_auth_tok_list;
 	struct mutex global_auth_tok_list_mutex;
+	struct list_head boundary_key_list;
 	size_t global_default_cipher_key_size;
 	size_t global_default_fn_cipher_key_bytes;
 	unsigned char global_default_cipher_name[ECRYPTFS_MAX_CIPHER_NAME_SIZE
@@ -768,4 +777,10 @@ ecryptfs_parse_tag_70_packet(char **filename, size_t *filename_size,
 int ecryptfs_derive_iv(char *iv, struct ecryptfs_crypt_stat *crypt_stat,
 		       loff_t offset);
 
+int ecryptfs_find_boundary_key(struct ecryptfs_mount_crypt_stat *mount_crypt_stat,
+				uid_t uid, struct ecryptfs_boundary_key **boundary_key);
+void ecryptfs_generate_boundary_key(struct ecryptfs_crypt_stat *crypt_stat,
+				    struct ecryptfs_auth_tok *auth_tok,
+				    struct ecryptfs_boundary_key **boundary_key);
+				   
 #endif /* #ifndef ECRYPTFS_KERNEL_H */
diff --git a/fs/ecryptfs/file.c b/fs/ecryptfs/file.c
index 4ec9eb0..1745359 100644
--- a/fs/ecryptfs/file.c
+++ b/fs/ecryptfs/file.c
@@ -219,6 +219,7 @@ static int ecryptfs_open(struct inode *inode, struct file *file)
 	mutex_lock(&crypt_stat->cs_mutex);
 	if (!(crypt_stat->flags & ECRYPTFS_POLICY_APPLIED)
 	    || !(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {
+	    	crypt_stat->boundary_uid = inode->i_uid;
 		rc = ecryptfs_read_metadata(ecryptfs_dentry);
 		if (rc) {
 			ecryptfs_printk(KERN_DEBUG,
diff --git a/fs/ecryptfs/keystore.c b/fs/ecryptfs/keystore.c
index 89dc18e..f19b881 100644
--- a/fs/ecryptfs/keystore.c
+++ b/fs/ecryptfs/keystore.c
@@ -486,6 +486,23 @@ out:
 	return rc;
 }
 
+int ecryptfs_find_boundary_key(
+	struct ecryptfs_mount_crypt_stat *mount_crypt_stat,
+	uid_t uid, struct ecryptfs_boundary_key **boundary_key)
+{
+	struct ecryptfs_boundary_key *walker = NULL;
+
+	list_for_each_entry(walker, &mount_crypt_stat->boundary_key_list, 
+			    mount_crypt_stat_list) {
+		if (walker->uid == uid) {
+			*boundary_key = walker;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
 static int
 ecryptfs_find_global_auth_tok_for_sig(
 	struct key **auth_tok_key,
@@ -1664,6 +1681,8 @@ static int
 decrypt_passphrase_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,
 					 struct ecryptfs_crypt_stat *crypt_stat)
 {
+	struct ecryptfs_boundary_key *boundary_key;
+	u8 decryption_key[16];
 	struct scatterlist dst_sg[2];
 	struct scatterlist src_sg[2];
 	struct mutex *tfm_mutex;
@@ -1672,13 +1691,19 @@ decrypt_passphrase_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,
 	};
 	int rc = 0;
 
+	ecryptfs_printk(KERN_DEBUG, "uid: %d", (int) crypt_stat->boundary_uid);
+	if (!ecryptfs_find_boundary_key(crypt_stat->mount_crypt_stat, 
+				   crypt_stat->boundary_uid, &boundary_key)) 
+	{
+		ecryptfs_generate_boundary_key(crypt_stat,
+					       auth_tok, &boundary_key);
+	}
+	memcpy(decryption_key, boundary_key->key, crypt_stat->key_size);
+
 	if (unlikely(ecryptfs_verbosity > 0)) {
 		ecryptfs_printk(
-			KERN_DEBUG, "Session key encryption key (size [%d]):\n",
-			auth_tok->token.password.session_key_encryption_key_bytes);
-		ecryptfs_dump_hex(
-			auth_tok->token.password.session_key_encryption_key,
-			auth_tok->token.password.session_key_encryption_key_bytes);
+			KERN_DEBUG, "Session key encryption key:\n")
+		ecryptfs_dump_hex(decryption_key, crypt_stat->key_size);
 	}
 	rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,
 							crypt_stat->cipher);
@@ -1712,7 +1737,7 @@ decrypt_passphrase_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,
 	}
 	mutex_lock(tfm_mutex);
 	rc = crypto_blkcipher_setkey(
-		desc.tfm, auth_tok->token.password.session_key_encryption_key,
+		desc.tfm, decryption_key,
 		crypt_stat->key_size);
 	if (unlikely(rc < 0)) {
 		mutex_unlock(tfm_mutex);
@@ -1909,6 +1934,8 @@ found_matching_auth_tok:
 		rc = decrypt_pki_encrypted_session_key(candidate_auth_tok,
 						       crypt_stat);
 	} else if (candidate_auth_tok->token_type == ECRYPTFS_PASSWORD) {
+	// If Boundary mode, we should lookup by uid and copy that private key
+	// If uid lookup fails, then derive
 		memcpy(&(candidate_auth_tok->token.password),
 		       &(matching_auth_tok->token.password),
 		       sizeof(struct ecryptfs_password));
@@ -2184,6 +2211,7 @@ write_tag_3_packet(char *dest, size_t *remaining_bytes,
 	size_t i;
 	size_t encrypted_session_key_valid = 0;
 	char session_key_encryption_key[ECRYPTFS_MAX_KEY_BYTES];
+	struct ecryptfs_boundary_key *boundary_key = NULL;
 	struct scatterlist dst_sg[2];
 	struct scatterlist src_sg[2];
 	struct mutex *tfm_mutex = NULL;
@@ -2251,9 +2279,18 @@ write_tag_3_packet(char *dest, size_t *remaining_bytes,
 				"session key encryption key of size [%d]\n",
 				auth_tok->token.password.
 				session_key_encryption_key_bytes);
-		memcpy(session_key_encryption_key,
-		       auth_tok->token.password.session_key_encryption_key,
-		       crypt_stat->key_size);
+
+		if (BOUNDARY_MODE) {
+			// Switcheroo FEKEK to implement boundaries
+			ecryptfs_generate_boundary_key(crypt_stat, auth_tok,
+						       &boundary_key);
+			memcpy(session_key_encryption_key, boundary_key->key, 16);
+			ecryptfs_printk(KERN_DEBUG, "key size: %d", crypt_stat->key_size);
+		} else {
+			memcpy(session_key_encryption_key,
+			       auth_tok->token.password.session_key_encryption_key,
+			       crypt_stat->key_size);
+		}
 		ecryptfs_printk(KERN_DEBUG,
 				"Cached session key " "encryption key: \n");
 		if (ecryptfs_verbosity > 0)
diff --git a/fs/ecryptfs/main.c b/fs/ecryptfs/main.c
index b4a6bef..a74c270 100644
--- a/fs/ecryptfs/main.c
+++ b/fs/ecryptfs/main.c
@@ -230,6 +230,7 @@ static void ecryptfs_init_mount_crypt_stat(
 	memset((void *)mount_crypt_stat, 0,
 	       sizeof(struct ecryptfs_mount_crypt_stat));
 	INIT_LIST_HEAD(&mount_crypt_stat->global_auth_tok_list);
+	INIT_LIST_HEAD(&mount_crypt_stat->boundary_key_list);
 	mutex_init(&mount_crypt_stat->global_auth_tok_list_mutex);
 	mount_crypt_stat->flags |= ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED;
 }

commit 4dbf9d38e11b40b72720ddbafd2e16aec09fe09b
Author: Daniel DeFreez <defreezda@sou.edu>
Date:   Mon Jan 9 21:27:25 2012 -0800

    removed problematic debug messages

diff --git a/fs/ecryptfs/crypto.c b/fs/ecryptfs/crypto.c
index 58609bd..81bff8a 100644
--- a/fs/ecryptfs/crypto.c
+++ b/fs/ecryptfs/crypto.c
@@ -417,17 +417,6 @@ static int ecryptfs_encrypt_extent(struct page *enc_extent_page,
 			(unsigned long long)(extent_base + extent_offset), rc);
 		goto out;
 	}
-	if (unlikely(ecryptfs_verbosity > 0)) {
-		ecryptfs_printk(KERN_DEBUG, "Encrypting extent "
-				"with iv:\n");
-		ecryptfs_dump_hex(extent_iv, crypt_stat->iv_bytes);
-		ecryptfs_printk(KERN_DEBUG, "First 8 bytes before "
-				"encryption:\n");
-		ecryptfs_dump_hex((char *)
-				  (page_address(page)
-				   + (extent_offset * crypt_stat->extent_size)),
-				  8);
-	}
 	rc = ecryptfs_encrypt_page_offset(crypt_stat, enc_extent_page, 0,
 					  page, (extent_offset
 						 * crypt_stat->extent_size),
@@ -440,14 +429,6 @@ static int ecryptfs_encrypt_extent(struct page *enc_extent_page,
 		goto out;
 	}
 	rc = 0;
-	if (unlikely(ecryptfs_verbosity > 0)) {
-		ecryptfs_printk(KERN_DEBUG, "Encrypt extent [0x%.16llx]; "
-			"rc = [%d]\n",
-			(unsigned long long)(extent_base + extent_offset), rc);
-		ecryptfs_printk(KERN_DEBUG, "First 8 bytes after "
-				"encryption:\n");
-		ecryptfs_dump_hex((char *)(page_address(enc_extent_page)), 8);
-	}
 out:
 	return rc;
 }
@@ -543,17 +524,6 @@ static int ecryptfs_decrypt_extent(struct page *page,
 			(unsigned long long)(extent_base + extent_offset), rc);
 		goto out;
 	}
-	if (unlikely(ecryptfs_verbosity > 0)) {
-		ecryptfs_printk(KERN_DEBUG, "Decrypting extent "
-				"with iv:\n");
-		ecryptfs_dump_hex(extent_iv, crypt_stat->iv_bytes);
-		ecryptfs_printk(KERN_DEBUG, "First 8 bytes before "
-				"decryption:\n");
-		ecryptfs_dump_hex((char *)
-				  (page_address(enc_extent_page)
-				   + (extent_offset * crypt_stat->extent_size)),
-				  8);
-	}
 	rc = ecryptfs_decrypt_page_offset(crypt_stat, page,
 					  (extent_offset
 					   * crypt_stat->extent_size),
@@ -567,16 +537,6 @@ static int ecryptfs_decrypt_extent(struct page *page,
 		goto out;
 	}
 	rc = 0;
-	if (unlikely(ecryptfs_verbosity > 0)) {
-		ecryptfs_printk(KERN_DEBUG, "Decrypt extent [0x%.16llx]; "
-			"rc = [%d]\n",
-			(unsigned long long)(extent_base + extent_offset), rc);
-		ecryptfs_printk(KERN_DEBUG, "First 8 bytes after "
-				"decryption:\n");
-		ecryptfs_dump_hex((char *)(page_address(page)
-					   + (extent_offset
-					      * crypt_stat->extent_size)), 8);
-	}
 out:
 	return rc;
 }

commit cacae5e7d7279f4dcc74dcde5955a0b1f08673cd
Author: Daniel DeFreez <daniel@defreez.com>
Date:   Sat Jan 21 11:33:24 2012 -0800

    streamlined build-kernel.sh and enabled ikconfig

diff --git a/arch/arm/configs/thesis_defconfig b/arch/arm/configs/thesis_defconfig
index 50a30df..d2b9d38 100644
--- a/arch/arm/configs/thesis_defconfig
+++ b/arch/arm/configs/thesis_defconfig
@@ -384,3 +384,5 @@ CONFIG_CRYPTO_SHA256=y
 CONFIG_CRYPTO_TWOFISH=y
 CONFIG_CRC_CCITT=y
 CONFIG_KEYS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
diff --git a/build-kernel.sh b/build-kernel.sh
index 2996dc2..b3c45bf 100755
--- a/build-kernel.sh
+++ b/build-kernel.sh
@@ -1,16 +1,10 @@
 #!/bin/sh
 #
-# A small script used to rebuild the Android goldfish kernel image
-# See docs/KERNEL.TXT for usage instructions.
-#
-
-## Note, $FRAMEWORKSOURCE/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin is in $PATH
+# Based on emulator build-kernel.sh
 
-MACHINE=herring
-VARIANT=herring
 OUTPUT=/tmp/kernel-ics
 CROSSPREFIX=arm-eabi-
-CONFIG=herring
+CONFIG=thesis
 
 HOST_OS=linux
 HOST_TAG=linux-x86
@@ -21,114 +15,11 @@ JOBS=$(( $BUILD_NUM_CPUS * 2 ))
 
 ARCH=arm
 
-OPTION_HELP=no
-OPTION_ARMV7=no
-OPTION_OUT=
-OPTION_CROSS=
-OPTION_ARCH=
-OPTION_CONFIG=
-OPTION_JOBS=
-
-for opt do
-optarg=$(expr "x$opt" : 'x[^=]*=\(.*\)')
-    case $opt in
-    --help|-h|-\?) OPTION_HELP=yes
-        ;;
-    --armv7)
-        OPTION_ARMV7=yes
-        ;;
-    --out=*)
-        OPTION_OUT=$optarg
-        ;;
-    --cross=*)
-        OPTION_CROSS=$optarg
-        ;;
-    --arch=*)
-        OPTION_ARCH=$optarg
-        ;;
-    --config=*)
-        OPTION_CONFIG=$optarg
-        ;;
-    -j*)
-        OPTION_JOBS=$optarg
-        ;;
-    *)
-        echo "unknown option '$opt', use --help"
-        exit 1
-    esac
-done
-
-if [ $OPTION_HELP = "yes" ] ; then
-echo "Rebuild the prebuilt kernel binary for Android's emulator."
-    echo ""
-    echo "options (defaults are within brackets):"
-    echo ""
-    echo " --help print this message"
-    echo " --arch=<arch> change target architecture [$ARCH]"
-    echo " --armv7 build ARMv7 binaries (see note below)"
-    echo " --out=<directory> output directory [$OUTPUT]"
-    echo " --cross=<prefix> cross-toolchain prefix [$CROSSPREFIX]"
-    echo " --config=<name> kernel config name [$CONFIG]"
-    echo " -j<number> launch <number> parallel build jobs [$JOBS]"
-    echo ""
-    echo "NOTE: --armv7 is equivalent to --config=goldfish_armv7. It is"
-    echo " ignored if --config=<name> is used."
-    echo ""
-    exit 0
-fi
-
-if [ -n "$OPTION_ARCH" ]; then
-ARCH=$OPTION_ARCH
-fi
-
-if [ -n "$OPTION_CONFIG" ]; then
-CONFIG=$OPTION_CONFIG
-else
-if [ "$OPTION_ARMV7" = "yes" ]; then
-CONFIG=goldfish_armv7
-    fi
-echo "Auto-config: --config=$CONFIG"
-fi
-
-# Check that we are in the kernel directory
-if [ ! -d arch/$ARCH/mach-$MACHINE ] ; then
-echo "Cannot find arch/$ARCH/mach-$MACHINE. Please cd to the kernel source directory."
-    echo "Aborting."
-    #exit 1
-fi
-
-# Check output directory.
-if [ -n "$OPTION_OUT" ] ; then
-if [ ! -d "$OPTION_OUT" ] ; then
-echo "Output directory '$OPTION_OUT' does not exist ! Aborting."
-        exit 1
-    fi
-OUTPUT=$OPTION_OUT
-else
 mkdir -p $OUTPUT
-fi
 
-if [ -n "$OPTION_CROSS" ] ; then
-CROSSPREFIX="$OPTION_CROSS"
-else
-case $ARCH in
-        arm)
-            CROSSTOOLCHAIN=arm-eabi-4.4.3
-            CROSSPREFIX=arm-eabi-
-            ZIMAGE=zImage
-            ;;
-        x86)
-            CROSSTOOLCHAIN=i686-android-linux-4.4.3
-            CROSSPREFIX=i686-android-linux-
-            ZIMAGE=bzImage
-            ;;
-        *)
-            echo "ERROR: Unsupported architecture!"
-            exit 1
-            ;;
-    esac
-echo "Auto-config: --cross=$CROSSPREFIX"
-fi
+CROSSTOOLCHAIN=arm-eabi-4.4.3
+CROSSPREFIX=arm-eabi-
+ZIMAGE=zImage
 
 # If the cross-compiler is not in the path, try to find it automatically
 CROSS_COMPILER="${CROSSPREFIX}gcc"
@@ -156,12 +47,6 @@ fi
 
 export CROSS_COMPILE="$CROSSPREFIX" ARCH SUBARCH=$ARCH
 
-if [ "$OPTION_JOBS" ]; then
-JOBS=$OPTION_JOBS
-else
-echo "Auto-config: -j$JOBS"
-fi
-
 # Do the build
 #
 rm -f include/asm &&
@@ -173,28 +58,9 @@ echo "Could not build the kernel. Aborting !"
     exit 1
 fi
 
-# Note: The exact names of the output files are important for the Android build,
-# do not change the definitions lightly.
-case $CONFIG in
-    vbox*)
-        OUTPUT_KERNEL=kernel-vbox
-        OUTPUT_VMLINUX=vmlinux-vbox
-        ;;
-    goldfish)
-        OUTPUT_KERNEL=kernel-qemu
-        OUTPUT_VMLINUX=vmlinux-qemu
-        ;;
-    goldfish_armv7)
-        OUTPUT_KERNEL=kernel-qemu-armv7
-        OUTPUT_VMLINUX=vmlinux-qemu-armv7
-        ;;
-    *)
-        OUTPUT_KERNEL=kernel-$CONFIG
-        OUTPUT_VMLINUX=vmlinux-$CONFIG
-esac
+OUTPUT_KERNEL=kernel-$CONFIG
 
 cp -f arch/$ARCH/boot/$ZIMAGE $OUTPUT/$OUTPUT_KERNEL
-cp -f vmlinux $OUTPUT/$OUTPUT_VMLINUX
 
-echo "Kernel $CONFIG prebuilt images ($OUTPUT_KERNEL and $OUTPUT_VMLINUX) copied to $OUTPUT successfully !"
+echo "Kernel $CONFIG prebuilt image ($OUTPUT_KERNEL) copied to $OUTPUT successfully !"
 exit 0

commit 78462f859c30d48419b4a554a0e527c224c2e7c6
Author: Daniel DeFreez <daniel@defreez.com>
Date:   Sat Jan 21 09:35:10 2012 -0800

    added thesis config which builds ecryptfs

diff --git a/arch/arm/configs/thesis_defconfig b/arch/arm/configs/thesis_defconfig
new file mode 100644
index 0000000..50a30df
--- /dev/null
+++ b/arch/arm/configs/thesis_defconfig
@@ -0,0 +1,386 @@
+CONFIG_EXPERIMENTAL=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_PANIC_TIMEOUT=5
+CONFIG_KALLSYMS_ALL=y
+CONFIG_ASHMEM=y
+# CONFIG_AIO is not set
+CONFIG_EMBEDDED=y
+# CONFIG_PERF_EVENTS is not set
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_ARCH_S5PV210=y
+CONFIG_S3C_LOWLEVEL_UART_PORT=2
+CONFIG_S5P_HIGH_RES_TIMERS=y
+CONFIG_S5PV210_SD_CH0_8BIT=y
+CONFIG_MACH_HERRING=y
+CONFIG_WIFI_CONTROL_FUNC=y
+CONFIG_ARM_THUMBEE=y
+CONFIG_FIQ_DEBUGGER=y
+CONFIG_FIQ_DEBUGGER_CONSOLE=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_COMPACTION=y
+CONFIG_CMDLINE="console=ttyFIQ0"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_BINFMT_MISC=y
+CONFIG_WAKELOCK=y
+CONFIG_APM_EMULATION=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_PHONET=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_INGRESS=y
+CONFIG_NET_CLS_U32=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+CONFIG_NET_ACT_MIRRED=y
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_WIMAX=y
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+CONFIG_MTD=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_ONENAND=y
+CONFIG_MTD_ONENAND_SAMSUNG=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_MISC_DEVICES=y
+CONFIG_SENSORS_AK8973=y
+CONFIG_SENSORS_KR3DM=y
+CONFIG_UID_STAT=y
+CONFIG_APANIC=y
+CONFIG_SAMSUNG_JACK=y
+CONFIG_USB_SWITCH_FSA9480=y
+CONFIG_SAMSUNG_MODEMCTL=y
+CONFIG_PN544=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_DEBUG=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_UEVENT=y
+CONFIG_NETDEVICES=y
+CONFIG_IFB=y
+CONFIG_TUN=y
+CONFIG_BCM4329=m
+CONFIG_BCM4329_FW_PATH="/vendor/firmware/fw_bcm4329.bin"
+CONFIG_BCM4329_NVRAM_PATH="/vendor/firmware/nvram_net.txt"
+CONFIG_WIMAX_CMC7XX=y
+CONFIG_PPP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYPAD_CYPRESS_TOUCH=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=y
+CONFIG_TABLET_USB_AIPTEK=y
+CONFIG_TABLET_USB_GTCO=y
+CONFIG_TABLET_USB_HANWANG=y
+CONFIG_TABLET_USB_KBTAB=y
+CONFIG_TABLET_USB_WACOM=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_MXT224=y
+CONFIG_INPUT_MISC=y
+CONFIG_GYRO_K3G=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+CONFIG_OPTICAL_GP2A=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+CONFIG_HW_RANDOM=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_GPIO=y
+CONFIG_I2C_S3C2410=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_BATTERY_MAX17040=y
+CONFIG_BATTERY_S5PC110=y
+# CONFIG_HWMON is not set
+CONFIG_MFD_MAX8998=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_MAX8893=y
+CONFIG_REGULATOR_MAX8998=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_S5KA3DFX=y
+CONFIG_VIDEO_S5K4ECGX=y
+CONFIG_VIDEO_SAMSUNG=y
+CONFIG_VIDEO_SAMSUNG_V4L2=y
+CONFIG_VIDEO_FIMC=y
+# CONFIG_VIDEO_FIMC_MIPI is not set
+CONFIG_VIDEO_MFC50=y
+CONFIG_VIDEO_JPEG_V2=y
+CONFIG_PVR_SGX=y
+CONFIG_PVR_NEED_PVR_DPF=y
+CONFIG_PVR_NEED_PVR_ASSERT=y
+CONFIG_PVR_USSE_EDM_STATUS_DEBUG=y
+CONFIG_FB=y
+CONFIG_FB_S3C=y
+CONFIG_FB_S3C_NR_BUFFERS=7
+CONFIG_FB_S3C_TL2796=y
+CONFIG_FB_S3C_NT35580=y
+# CONFIG_FB_S3C_LVDS is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_SAMSUNG=y
+CONFIG_SND_SOC_SAMSUNG_HERRING_WM8994=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWII_FF=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+CONFIG_HID_QUANTA=y
+CONFIG_HID_ROCCAT_ARVO=y
+CONFIG_HID_ROCCAT_KONE=y
+CONFIG_HID_ROCCAT_KONEPLUS=y
+CONFIG_HID_ROCCAT_KOVAPLUS=y
+CONFIG_HID_ROCCAT_PYRA=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_WACOM=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_G_ANDROID=y
+CONFIG_USB_ANDROID_RNDIS_DWORD_ALIGNED=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_S3C=y
+CONFIG_MMC_SDHCI_S3C_DMA=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_S3C=y
+CONFIG_STAGING=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4_FS_XATTR is not set
+# CONFIG_DNOTIFY is not set
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_YAFFS_FS=y
+CONFIG_ECRYPT_FS=y
+CONFIG_CRAMFS=y
+CONFIG_ROMFS_FS=y
+CONFIG_SYSV_FS=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_PREEMPT is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_S3C_UART=2
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRC_CCITT=y
+CONFIG_KEYS=y

commit 8ce22fec35e38cab1d610d078025cb6b9cd0ff20
Merge: f8ce2c2 eef8e7b
Author: Daniel DeFreez <daniel@defreez.com>
Date:   Thu Jan 19 21:01:24 2012 -0800

    Merge branch 'master' of github.com:defreez/thesis-kernel-ics-ecryptfs into android-samsung-3.0-ics-mr1

commit f8ce2c2f8b5568df87342bad88cc6d8a5381dab4
Author: Daniel DeFreez <daniel@defreez.com>
Date:   Thu Jan 19 20:57:17 2012 -0800

    convenient build script

diff --git a/build-kernel.sh b/build-kernel.sh
new file mode 100755
index 0000000..2996dc2
--- /dev/null
+++ b/build-kernel.sh
@@ -0,0 +1,200 @@
+#!/bin/sh
+#
+# A small script used to rebuild the Android goldfish kernel image
+# See docs/KERNEL.TXT for usage instructions.
+#
+
+## Note, $FRAMEWORKSOURCE/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin is in $PATH
+
+MACHINE=herring
+VARIANT=herring
+OUTPUT=/tmp/kernel-ics
+CROSSPREFIX=arm-eabi-
+CONFIG=herring
+
+HOST_OS=linux
+HOST_TAG=linux-x86
+BUILD_NUM_CPUS=$(grep -c processor /proc/cpuinfo)
+
+# Default number of parallel jobs during the build: cores * 2
+JOBS=$(( $BUILD_NUM_CPUS * 2 ))
+
+ARCH=arm
+
+OPTION_HELP=no
+OPTION_ARMV7=no
+OPTION_OUT=
+OPTION_CROSS=
+OPTION_ARCH=
+OPTION_CONFIG=
+OPTION_JOBS=
+
+for opt do
+optarg=$(expr "x$opt" : 'x[^=]*=\(.*\)')
+    case $opt in
+    --help|-h|-\?) OPTION_HELP=yes
+        ;;
+    --armv7)
+        OPTION_ARMV7=yes
+        ;;
+    --out=*)
+        OPTION_OUT=$optarg
+        ;;
+    --cross=*)
+        OPTION_CROSS=$optarg
+        ;;
+    --arch=*)
+        OPTION_ARCH=$optarg
+        ;;
+    --config=*)
+        OPTION_CONFIG=$optarg
+        ;;
+    -j*)
+        OPTION_JOBS=$optarg
+        ;;
+    *)
+        echo "unknown option '$opt', use --help"
+        exit 1
+    esac
+done
+
+if [ $OPTION_HELP = "yes" ] ; then
+echo "Rebuild the prebuilt kernel binary for Android's emulator."
+    echo ""
+    echo "options (defaults are within brackets):"
+    echo ""
+    echo " --help print this message"
+    echo " --arch=<arch> change target architecture [$ARCH]"
+    echo " --armv7 build ARMv7 binaries (see note below)"
+    echo " --out=<directory> output directory [$OUTPUT]"
+    echo " --cross=<prefix> cross-toolchain prefix [$CROSSPREFIX]"
+    echo " --config=<name> kernel config name [$CONFIG]"
+    echo " -j<number> launch <number> parallel build jobs [$JOBS]"
+    echo ""
+    echo "NOTE: --armv7 is equivalent to --config=goldfish_armv7. It is"
+    echo " ignored if --config=<name> is used."
+    echo ""
+    exit 0
+fi
+
+if [ -n "$OPTION_ARCH" ]; then
+ARCH=$OPTION_ARCH
+fi
+
+if [ -n "$OPTION_CONFIG" ]; then
+CONFIG=$OPTION_CONFIG
+else
+if [ "$OPTION_ARMV7" = "yes" ]; then
+CONFIG=goldfish_armv7
+    fi
+echo "Auto-config: --config=$CONFIG"
+fi
+
+# Check that we are in the kernel directory
+if [ ! -d arch/$ARCH/mach-$MACHINE ] ; then
+echo "Cannot find arch/$ARCH/mach-$MACHINE. Please cd to the kernel source directory."
+    echo "Aborting."
+    #exit 1
+fi
+
+# Check output directory.
+if [ -n "$OPTION_OUT" ] ; then
+if [ ! -d "$OPTION_OUT" ] ; then
+echo "Output directory '$OPTION_OUT' does not exist ! Aborting."
+        exit 1
+    fi
+OUTPUT=$OPTION_OUT
+else
+mkdir -p $OUTPUT
+fi
+
+if [ -n "$OPTION_CROSS" ] ; then
+CROSSPREFIX="$OPTION_CROSS"
+else
+case $ARCH in
+        arm)
+            CROSSTOOLCHAIN=arm-eabi-4.4.3
+            CROSSPREFIX=arm-eabi-
+            ZIMAGE=zImage
+            ;;
+        x86)
+            CROSSTOOLCHAIN=i686-android-linux-4.4.3
+            CROSSPREFIX=i686-android-linux-
+            ZIMAGE=bzImage
+            ;;
+        *)
+            echo "ERROR: Unsupported architecture!"
+            exit 1
+            ;;
+    esac
+echo "Auto-config: --cross=$CROSSPREFIX"
+fi
+
+# If the cross-compiler is not in the path, try to find it automatically
+CROSS_COMPILER="${CROSSPREFIX}gcc"
+CROSS_COMPILER_VERSION=$($CROSS_COMPILER --version 2>/dev/null)
+if [ $? != 0 ] ; then
+BUILD_TOP=$ANDROID_BUILD_TOP
+    if [ -z "$BUILD_TOP" ]; then
+        # Assume this script is under a kernel directory in root
+        # Android source tree.
+        BUILD_TOP=$(dirname $0)/..
+        if [ ! -d "$BUILD_TOP/prebuilt" ]; then
+BUILD_TOP=
+        else
+BUILD_TOP=$(cd $BUILD_TOP && pwd)
+        fi
+fi
+CROSSPREFIX=$BUILD_TOP/prebuilt/$HOST_TAG/toolchain/$CROSSTOOLCHAIN/bin/$CROSSPREFIX
+    if [ "$BUILD_TOP" -a -f ${CROSSPREFIX}gcc ]; then
+echo "Auto-config: --cross=$CROSSPREFIX"
+    else
+echo "It looks like $CROSS_COMPILER is not in your path ! Aborting."
+        exit 1
+    fi
+fi
+
+export CROSS_COMPILE="$CROSSPREFIX" ARCH SUBARCH=$ARCH
+
+if [ "$OPTION_JOBS" ]; then
+JOBS=$OPTION_JOBS
+else
+echo "Auto-config: -j$JOBS"
+fi
+
+# Do the build
+#
+rm -f include/asm &&
+make ${CONFIG}_defconfig && # configure the kernel
+make -j$JOBS # build it
+
+if [ $? != 0 ] ; then
+echo "Could not build the kernel. Aborting !"
+    exit 1
+fi
+
+# Note: The exact names of the output files are important for the Android build,
+# do not change the definitions lightly.
+case $CONFIG in
+    vbox*)
+        OUTPUT_KERNEL=kernel-vbox
+        OUTPUT_VMLINUX=vmlinux-vbox
+        ;;
+    goldfish)
+        OUTPUT_KERNEL=kernel-qemu
+        OUTPUT_VMLINUX=vmlinux-qemu
+        ;;
+    goldfish_armv7)
+        OUTPUT_KERNEL=kernel-qemu-armv7
+        OUTPUT_VMLINUX=vmlinux-qemu-armv7
+        ;;
+    *)
+        OUTPUT_KERNEL=kernel-$CONFIG
+        OUTPUT_VMLINUX=vmlinux-$CONFIG
+esac
+
+cp -f arch/$ARCH/boot/$ZIMAGE $OUTPUT/$OUTPUT_KERNEL
+cp -f vmlinux $OUTPUT/$OUTPUT_VMLINUX
+
+echo "Kernel $CONFIG prebuilt images ($OUTPUT_KERNEL and $OUTPUT_VMLINUX) copied to $OUTPUT successfully !"
+exit 0
